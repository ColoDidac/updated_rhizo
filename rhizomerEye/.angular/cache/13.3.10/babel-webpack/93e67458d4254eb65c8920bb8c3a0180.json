{"ast":null,"code":"import { EventEmitter, Component, forwardRef, ElementRef, NgZone, Input, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { getEditorNamespace } from 'ckeditor4-integrations-common';\n/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction CKEditorComponent_ng_template_0_Template(rf, ctx) {}\n\nlet CKEditorComponent = /*#__PURE__*/(() => {\n  class CKEditorComponent {\n    constructor(elementRef, ngZone) {\n      this.elementRef = elementRef;\n      this.ngZone = ngZone;\n      /**\n       * CKEditor 4 script url address. Script will be loaded only if CKEDITOR namespace is missing.\n       *\n       * Defaults to 'https://cdn.ckeditor.com/4.17.1/standard-all/ckeditor.js'\n       */\n\n      this.editorUrl = 'https://cdn.ckeditor.com/4.17.1/standard-all/ckeditor.js';\n      /**\n       * Tag name of the editor component.\n       *\n       * The default tag is `textarea`.\n       */\n\n      this.tagName = 'textarea';\n      /**\n       * The type of the editor interface.\n       *\n       * By default editor interface will be initialized as `classic` editor.\n       * You can also choose to create an editor with `inline` interface type instead.\n       *\n       * See https://ckeditor.com/docs/ckeditor4/latest/guide/dev_uitypes.html\n       * and https://ckeditor.com/docs/ckeditor4/latest/examples/fixedui.html\n       * to learn more.\n       */\n\n      this.type = \"classic\"\n      /* CLASSIC */\n      ;\n      /**\n       * Fired when the CKEDITOR https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR.html namespace\n       * is loaded. It only triggers once, no matter how many CKEditor 4 components are initialised.\n       * Can be used for convenient changes in the namespace, e.g. for adding external plugins.\n       */\n\n      this.namespaceLoaded = new EventEmitter();\n      /**\n       * Fires when the editor is ready. It corresponds with the `editor#instanceReady`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-instanceReady\n       * event.\n       */\n\n      this.ready = new EventEmitter();\n      /**\n       * Fires when the editor data is loaded, e.g. after calling setData()\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#method-setData\n       * editor's method. It corresponds with the `editor#dataReady`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-dataReady event.\n       */\n\n      this.dataReady = new EventEmitter();\n      /**\n       * Fires when the content of the editor has changed. It corresponds with the `editor#change`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-change\n       * event. For performance reasons this event may be called even when data didn't really changed.\n       * Please note that this event will only be fired when `undo` plugin is loaded. If you need to\n       * listen for editor changes (e.g. for two-way data binding), use `dataChange` event instead.\n       */\n\n      this.change = new EventEmitter();\n      /**\n       * Fires when the content of the editor has changed. In contrast to `change` - only emits when\n       * data really changed thus can be successfully used with `[data]` and two way `[(data)]` binding.\n       *\n       * See more: https://angular.io/guide/template-syntax#two-way-binding---\n       */\n\n      this.dataChange = new EventEmitter();\n      /**\n       * Fires when the native dragStart event occurs. It corresponds with the `editor#dragstart`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-dragstart\n       * event.\n       */\n\n      this.dragStart = new EventEmitter();\n      /**\n       * Fires when the native dragEnd event occurs. It corresponds with the `editor#dragend`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-dragend\n       * event.\n       */\n\n      this.dragEnd = new EventEmitter();\n      /**\n       * Fires when the native drop event occurs. It corresponds with the `editor#drop`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-drop\n       * event.\n       */\n\n      this.drop = new EventEmitter();\n      /**\n       * Fires when the file loader response is received. It corresponds with the `editor#fileUploadResponse`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-fileUploadResponse\n       * event.\n       */\n\n      this.fileUploadResponse = new EventEmitter();\n      /**\n       * Fires when the file loader should send XHR. It corresponds with the `editor#fileUploadRequest`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-fileUploadRequest\n       * event.\n       */\n\n      this.fileUploadRequest = new EventEmitter();\n      /**\n       * Fires when the editing area of the editor is focused. It corresponds with the `editor#focus`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-focus\n       * event.\n       */\n\n      this.focus = new EventEmitter();\n      /**\n       * Fires after the user initiated a paste action, but before the data is inserted.\n       * It corresponds with the `editor#paste`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-paste\n       * event.\n       */\n\n      this.paste = new EventEmitter();\n      /**\n       * Fires after the `paste` event if content was modified. It corresponds with the `editor#afterPaste`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-afterPaste\n       * event.\n       */\n\n      this.afterPaste = new EventEmitter();\n      /**\n       * Fires when the editing view of the editor is blurred. It corresponds with the `editor#blur`\n       * https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#event-blur\n       * event.\n       */\n\n      this.blur = new EventEmitter();\n      /**\n       * If the component is read–only before the editor instance is created, it remembers that state,\n       * so the editor can become read–only once it is ready.\n       */\n\n      this._readOnly = null;\n      this._data = null;\n      this._destroyed = false;\n    }\n    /**\n     * Keeps track of the editor's data.\n     *\n     * It's also decorated as an input which is useful when not using the ngModel.\n     *\n     * See https://angular.io/api/forms/NgModel to learn more.\n     */\n\n\n    set data(data) {\n      if (data === this._data) {\n        return;\n      }\n\n      if (this.instance) {\n        this.instance.setData(data); // Data may be changed by ACF.\n\n        this._data = this.instance.getData();\n        return;\n      }\n\n      this._data = data;\n    }\n\n    get data() {\n      return this._data;\n    }\n    /**\n     * When set to `true`, the editor becomes read-only.\n     *\n     * See https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html#property-readOnly\n     * to learn more.\n     */\n\n\n    set readOnly(isReadOnly) {\n      if (this.instance) {\n        this.instance.setReadOnly(isReadOnly);\n        return;\n      } // Delay setting read-only state until editor initialization.\n\n\n      this._readOnly = isReadOnly;\n    }\n\n    get readOnly() {\n      if (this.instance) {\n        return this.instance.readOnly;\n      }\n\n      return this._readOnly;\n    }\n\n    ngAfterViewInit() {\n      getEditorNamespace(this.editorUrl, namespace => {\n        this.namespaceLoaded.emit(namespace);\n      }).then(() => {\n        // Check if component instance was destroyed before `ngAfterViewInit` call (#110).\n        // Here, `this.instance` is still not initialized and so additional flag is needed.\n        if (this._destroyed) {\n          return;\n        }\n\n        this.ngZone.runOutsideAngular(this.createEditor.bind(this));\n      }).catch(window.console.error);\n    }\n\n    ngOnDestroy() {\n      this._destroyed = true;\n      this.ngZone.runOutsideAngular(() => {\n        if (this.instance) {\n          this.instance.destroy();\n          this.instance = null;\n        }\n      });\n    }\n\n    writeValue(value) {\n      this.data = value;\n    }\n\n    registerOnChange(callback) {\n      this.onChange = callback;\n    }\n\n    registerOnTouched(callback) {\n      this.onTouched = callback;\n    }\n\n    createEditor() {\n      var _a, _b;\n\n      const element = document.createElement(this.tagName);\n      this.elementRef.nativeElement.appendChild(element);\n      const userInstanceReadyCallback = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.on) === null || _b === void 0 ? void 0 : _b.instanceReady;\n      const defaultConfig = {\n        delayIfDetached: true\n      };\n      const config = Object.assign(Object.assign({}, defaultConfig), this.config);\n\n      if (typeof config.on === 'undefined') {\n        config.on = {};\n      }\n\n      config.on.instanceReady = evt => {\n        const editor = evt.editor;\n        this.instance = editor; // Read only state may change during instance initialization.\n\n        this.readOnly = this._readOnly !== null ? this._readOnly : this.instance.readOnly;\n        this.subscribe(this.instance);\n        const undo = editor.undoManager;\n\n        if (this.data !== null) {\n          undo && undo.lock();\n          editor.setData(this.data, {\n            callback: () => {\n              // Locking undoManager prevents 'change' event.\n              // Trigger it manually to updated bound data.\n              if (this.data !== editor.getData()) {\n                undo ? editor.fire('change') : editor.fire('dataReady');\n              }\n\n              undo && undo.unlock();\n              this.ngZone.run(() => {\n                if (typeof userInstanceReadyCallback === 'function') {\n                  userInstanceReadyCallback(evt);\n                }\n\n                this.ready.emit(evt);\n              });\n            }\n          });\n        } else {\n          this.ngZone.run(() => {\n            if (typeof userInstanceReadyCallback === 'function') {\n              userInstanceReadyCallback(evt);\n            }\n\n            this.ready.emit(evt);\n          });\n        }\n      };\n\n      if (this.type === \"inline\"\n      /* INLINE */\n      ) {\n        CKEDITOR.inline(element, config);\n      } else {\n        CKEDITOR.replace(element, config);\n      }\n    }\n\n    subscribe(editor) {\n      editor.on('focus', evt => {\n        this.ngZone.run(() => {\n          this.focus.emit(evt);\n        });\n      });\n      editor.on('paste', evt => {\n        this.ngZone.run(() => {\n          this.paste.emit(evt);\n        });\n      });\n      editor.on('afterPaste', evt => {\n        this.ngZone.run(() => {\n          this.afterPaste.emit(evt);\n        });\n      });\n      editor.on('dragend', evt => {\n        this.ngZone.run(() => {\n          this.dragEnd.emit(evt);\n        });\n      });\n      editor.on('dragstart', evt => {\n        this.ngZone.run(() => {\n          this.dragStart.emit(evt);\n        });\n      });\n      editor.on('drop', evt => {\n        this.ngZone.run(() => {\n          this.drop.emit(evt);\n        });\n      });\n      editor.on('fileUploadRequest', evt => {\n        this.ngZone.run(() => {\n          this.fileUploadRequest.emit(evt);\n        });\n      });\n      editor.on('fileUploadResponse', evt => {\n        this.ngZone.run(() => {\n          this.fileUploadResponse.emit(evt);\n        });\n      });\n      editor.on('blur', evt => {\n        this.ngZone.run(() => {\n          if (this.onTouched) {\n            this.onTouched();\n          }\n\n          this.blur.emit(evt);\n        });\n      });\n      editor.on('dataReady', this.propagateChange, this);\n\n      if (this.instance.undoManager) {\n        editor.on('change', this.propagateChange, this);\n      } // If 'undo' plugin is not loaded, listen to 'selectionCheck' event instead. (#54).\n      else {\n        editor.on('selectionCheck', this.propagateChange, this);\n      }\n    }\n\n    propagateChange(event) {\n      this.ngZone.run(() => {\n        const newData = this.instance.getData();\n\n        if (event.name === 'change') {\n          this.change.emit(event);\n        } else if (event.name === 'dataReady') {\n          this.dataReady.emit(event);\n        }\n\n        if (newData === this.data) {\n          return;\n        }\n\n        this._data = newData;\n        this.dataChange.emit(newData);\n\n        if (this.onChange) {\n          this.onChange(newData);\n        }\n      });\n    }\n\n  }\n\n  CKEditorComponent.ɵfac = function CKEditorComponent_Factory(t) {\n    return new (t || CKEditorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  CKEditorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CKEditorComponent,\n    selectors: [[\"ckeditor\"]],\n    inputs: {\n      editorUrl: \"editorUrl\",\n      tagName: \"tagName\",\n      type: \"type\",\n      data: \"data\",\n      readOnly: \"readOnly\",\n      config: \"config\"\n    },\n    outputs: {\n      namespaceLoaded: \"namespaceLoaded\",\n      ready: \"ready\",\n      dataReady: \"dataReady\",\n      change: \"change\",\n      dataChange: \"dataChange\",\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\",\n      drop: \"drop\",\n      fileUploadResponse: \"fileUploadResponse\",\n      fileUploadRequest: \"fileUploadRequest\",\n      focus: \"focus\",\n      paste: \"paste\",\n      afterPaste: \"afterPaste\",\n      blur: \"blur\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CKEditorComponent),\n      multi: true\n    }])],\n    decls: 1,\n    vars: 0,\n    template: function CKEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, CKEditorComponent_ng_template_0_Template, 0, 0, \"ng-template\");\n      }\n    },\n    encapsulation: 2\n  });\n  return CKEditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n\nlet CKEditorModule = /*#__PURE__*/(() => {\n  class CKEditorModule {}\n\n  CKEditorModule.ɵfac = function CKEditorModule_Factory(t) {\n    return new (t || CKEditorModule)();\n  };\n\n  CKEditorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CKEditorModule\n  });\n  CKEditorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule]]\n  });\n  return CKEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CKEditorModule, {\n    declarations: function () {\n      return [CKEditorComponent];\n    },\n    imports: function () {\n      return [FormsModule, CommonModule];\n    },\n    exports: function () {\n      return [CKEditorComponent];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CKEditorComponent, CKEditorModule }; //# sourceMappingURL=ckeditor4-angular.js.map","map":null,"metadata":{},"sourceType":"module"}